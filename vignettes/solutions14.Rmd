---
title: "Chapter 14: Ecology"
author: "Robin Lovelace, Jakub Nowosad, Jannes Muenchow"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{geocompr-solutions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

## Prerequisites {-}

The solutions assume the following packages are attached (other packages will be attached when needed):

```{r packages, message=FALSE, warning=FALSE}
library(sf)
library(raster)
library(vegan)
```

# Chapter 14

1. Run a NMDS using the percentage data of the community matrix. 
Report the stress value and compare it to the stress value as retrieved from the NMDS using presence-absence data.
What might explain the observed difference?

```{r, cache=TRUE}
library(vegan)
data("study_area", "random_points", "comm", "dem", "ndvi", package = "RQGIS")
pa = decostand(comm, "pa")

set.seed(25072018)
nmds_pa = metaMDS(comm = pa, k = 4, try = 500)
nmds_per = metaMDS(comm = comm, k = 4, try = 500)
nmds_pa$stress
nmds_per$stress
```

The NMDS using the presence-absence values yields a better result (`nmds_pa$stress`) than the one using percentage data (`nmds_per$stress`).
This might seem surprising at first sight.
On the other hand, the percentag matrix contains both more information and more noise.
Another aspect is how the data was collected.
Imagine a botanist in the field.
It might seem feasible to differentiate between a plant which has a cover of 5% and another species that covers 10%.
However, what about a herbal species that was only detected three times and consequently has a very tiny cover, e.g., 0.0001%. 
Maybe another herbal species was detected 6 times, is its cover then 0.0002%?
The point here is that percentage data as specified during a field campaign might reflect a precision that the data does not have.
This again introduces noise which in turn will worsen the ordination result.
Still, it is a valuable information if one species had a higher frequency or coverage in one plot than another compared to just presence-absence data.
One compromise would be to use a categorical scale such as the Londo scale.

2. Compute catchment area and catchment slope using **RSAGA** (see this [section](https://geocompr.robinlovelace.net/gis.html#rsaga)).

```{r, eval=FALSE}
library("RSAGA")
# check if rsaga.env can find the corresponding SAGA installation
rsaga.env()
rsaga.get.libraries()
rsaga.get.modules(libs = "ta_hydrology")
rsaga.get.usage(lib = "ta_hydrology", module = "SAGA Wetness Index")
# RSAGA only accepts files living on disk, so we have to save dem 
raster::writeRaster(dem, filename = file.path(tempdir(), "dem.sdat"),
                    format = "SAGA")
# construct a parameter-argument list
params = list(DEM = file.path(tempdir(), "dem.sgrd"),
              AREA = file.path(tempdir(), "carea.sdat"),
              SLOPE = file.path(tempdir(), "cslope.sdata"),
              AREA_TYPE = 0,
              SLOPE_TYPE = 1)
rsaga.geoprocessor(lib = "ta_hydrology", module = "SAGA Wetness Index",
                   param = params)
# load the output back into R again
out = stack(file.path(tempdir(), "carea.sdat"), 
            file.path(tempdir(), "cslope.sdat"))
plot(out)
```

3. Compute all the predictor rasters we have used in the chapter (catchment slope, catchment area), and put them in a raster stack.
Add `dem` and `ndvi` to the raster stack.
Next, compute profile and tangential curvature as additional predictor rasters and put them also in the raster stack (hint: `grass7:r.slope.aspect`).
Finally, construct a response-predictor matrix. 
The scores of the first NMDS axis (which were the result when using the presence-absence community matrix) rotated in accordance with elevation  represent the response variable, and should be joined to `random_points` (use an inner join).
Extract also the values of the environmental predictor raster stack to `random_points`.

```{r, eval=FALSE}
# first compute the terrain attributes we have also used in the chapter
library(RQGIS)
library(dplyr)
library(raster)
library(vegan)

data("dem", package = "RQGIS")
ep = run_qgis(alg = "saga:sagawetnessindex",
              DEM = dem,
              SLOPE_TYPE = 1, 
              SLOPE = tempfile(fileext = ".sdat"),
              AREA = tempfile(fileext = ".sdat"),
              load_output = TRUE,
              show_output_paths = FALSE)
ep = c(dem, ndvi, ep) %>%
  stack()
names(ep) = c("dem", "ndvi", "carea", "cslope")
ep$carea = log10(ep$carea)
# computing the curvatures
get_usage("grass7:r.slope.aspect")
curvs = run_qgis("grass7:r.slope.aspect",
                 elevation = dem,
                 pcurvature = file.path(tempdir(), "pcurvature.tif"),
                 tcurvature = file.path(tempdir(), "tcurvature.tif"),
                 load_output = TRUE)
# adding curvatures to ep
ep = addLayer(ep, curvs$pcurvature, curvs$tcurvature)
random_points[, names(ep)] = raster::extract(ep, as(random_points, "Spatial"))
elev = dplyr::filter(random_points, id %in% rownames(pa)) %>% 
  dplyr::pull(dem)
# rotating NMDS in accordance with altitude (proxy for humidity)
rotnmds = MDSrotate(nmds_pa, elev)
# extracting the first two axes
sc = scores(rotnmds, choices = 1:2)
rp = data.frame(id = as.numeric(rownames(sc)),
                sc = sc[, 1])
# join the predictors (dem, ndvi and terrain attributes)
rp = inner_join(random_points, rp, by = "id")
```

4. Retrieve the bias-reduced RMSE using spatial cross-validation including the estimation of optimal hyperparameter combinations (random search with 50 iterations) in an inner tuning loop (see [section](https://geocompr.robinlovelace.net/spatial-cv.html#svm)).
Parallelize the tuning level (see section [section](https://geocompr.robinlovelace.net/spatial-cv.html#svm)).
Report the mean RMSE and use a boxplot to visualize all retrieved RMSEs.

```{r, eval=FALSE}

```
